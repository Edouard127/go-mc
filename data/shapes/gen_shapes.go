//go:build generate
// +build generate

package main

import (
	"encoding/json"
	"fmt"
	"github.com/iancoleman/strcase"
	"net/http"
	"os"
	"text/template"
)

const (
	version = "1.19"
	infoURL = "https://raw.githubusercontent.com/PrismarineJS/minecraft-data/master/data/pc/" + version + "/blockCollisionShapes.json"
	//language=gohtml
	entityTmpl = `// Code generated by gen_shapes.go DO NOT EDIT.
// Package shapes stores information about block collision shapes in Minecraft.
package shapes

import (
	"github.com/Tnze/go-mc/bot/maths"
)

// Shape describes information about a block collision shape.
type Shape struct {
	Shapes map[int][]maths.AxisAlignedBB[float64]
}

var (
	{{- range $name, $shape := .}}
		{{ (camelcase $name) }} = Shape{
			Shapes: map[int][]maths.AxisAlignedBB[float64]{
				{{- range $k, $v := $shape}}
				{{$k}}: []maths.AxisAlignedBB[float64]{
					{{- range $v}}
						maths.AxisAlignedBB[float64]{
							MinX: {{index . 0}}, MinY: {{index . 1}}, MinZ: {{index . 2}},
							MaxX: {{index . 3}}, MaxY: {{index . 4}}, MaxZ: {{index . 5}},
						},
					{{- end}}
				},
				{{- end}}
			},
		}
	{{- end}}
)


var BlockShapes = map[string]Shape{
	{{- range $k, $v := .}}
	"{{$k}}": {{(camelcase $k)}},
	{{- end}}
}

func GetShape(name string, data int) maths.AxisAlignedBB[float64] {
	// Contact me if you'd like to write 935 different functions.
	return BlockShapes[name].Shapes[data][0]
}
`
)

type shape struct {
	Blocks map[string]interface{}  `json:"blocks"`
	Shapes map[string][][6]float64 `json:"shapes"`
}

func downloadInfo() (*shape, error) {
	resp, err := http.Get(infoURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var data *shape
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return nil, err
	}
	return data, nil
}

//go:generate go run $GOFILE
//go:generate go fmt shapes.go
func main() {
	shapes, err := downloadInfo()
	if err != nil {
		panic(err)
	}

	// New format: map[string]map[int][][6]float64
	newShapes := make(map[string]map[int][][6]float64)

	for k, v := range shapes.Blocks {
		newShapes[k] = make(map[int][][6]float64)

		switch v.(type) {
		case float64:
			newShapes[k][0] = shapes.Shapes[fmt.Sprintf("%v", v)]
		case []interface{}:
			for _, v2 := range v.([]interface{}) {
				newShapes[k][int(v2.(float64))] = shapes.Shapes[fmt.Sprintf("%v", v2)]
			}
		}
	}

	f, err := os.Create("shapes.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if err := template.Must(template.New("").Funcs(template.FuncMap{
		"camelcase": strcase.ToCamel,
	}).Parse(entityTmpl)).Execute(f, newShapes); err != nil {
		panic(err)
	}
}
