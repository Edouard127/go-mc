//go:build generate
// +build generate

package main

import (
	"encoding/json"
	"fmt"
	"github.com/iancoleman/strcase"
	"net/http"
	"os"
	"text/template"
)

const (
	version = "1.19"
	infoURL = "https://raw.githubusercontent.com/PrismarineJS/minecraft-data/master/data/pc/" + version + "/blockCollisionShapes.json"
	//language=gohtml
	entityTmpl = `// Code generated by gen_shapes.go DO NOT EDIT.
// Package shapes stores information about block collision shapes in Minecraft.
package shapes

// Shape describes information about a block collision shape.
type Shape struct {
	Shapes map[int][][6]float64
}

var (
	{{- range $name, $shape := .}}
		{{ (camelcase $name) }} = Shape{
			Shapes: map[int][][6]float64{
				{{- range $k, $v := $shape}}
				{{$k}}: [][6]float64{
					{{- range $v}}
						{{- printf "%#v" .}},
					{{- end}}
				},
				{{- end}}
			},
		}
	{{- end}}
)


var BlockShapes = map[string]Shape{
	{{- range $k, $v := .}}
	"minecraft:{{$k}}": {{(camelcase $k)}},
	{{- end}}
}

func GetShape(name string, data int) [6]float64 {
	block := BlockShapes[name]
	if state, ok := block.Shapes[0]; ok {
		return state[0]
	} else {
		return block.Shapes[data][0]
	}
}
`
)

type shape struct {
	Blocks map[string]interface{}  `json:"blocks"`
	Shapes map[string][][6]float64 `json:"shapes"`
}

func downloadInfo() (*shape, error) {
	resp, err := http.Get(infoURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var data *shape
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return nil, err
	}
	return data, nil
}

//go:generate go run $GOFILE
//go:generate go fmt shapes.go
func main() {
	shapes, err := downloadInfo()
	if err != nil {
		panic(err)
	}

	// New format: map[string]map[int][][6]float64
	newShapes := make(map[string]map[int][][6]float64)

	for k, v := range shapes.Blocks {
		newShapes[k] = make(map[int][][6]float64)

		switch v.(type) {
		case float64:
			aabb := shapes.Shapes[fmt.Sprintf("%v", v)]
			if len(aabb) == 0 {
				aabb = [][6]float64{
					{0, 0, 0, 0, 0, 0},
				}
			}
			newShapes[k][0] = aabb
		case []interface{}:
			for _, v2 := range v.([]interface{}) {
				aabb := shapes.Shapes[fmt.Sprintf("%v", v)]
				if len(aabb) == 0 {
					aabb = [][6]float64{
						{0, 0, 0, 0, 0, 0},
					}
				}
				newShapes[k][int(v2.(float64))] = aabb
			}
		}
	}

	f, err := os.Create("shapes.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if err := template.Must(template.New("").Funcs(template.FuncMap{
		"camelcase": strcase.ToCamel,
	}).Parse(entityTmpl)).Execute(f, newShapes); err != nil {
		panic(err)
	}
}
